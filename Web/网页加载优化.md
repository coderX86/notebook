# 网络性能优化
   1. 分析过程，从请求到页面：
       1. 建立连接
          1. 查找域名的IP地址
          2. 给查找的地址发起HTTP请求
          3. 服务器发送永久重定向响应
          4. 浏览器重定向
          5. 服务器处理请求
          6. 服务器发送响应结果
       2. 渲染 
          1. 加载HTML
          2. 加载HTML中引用的资源
          3. 构建DOM树
          4. 渲染树构建
          5. 渲染树布局
   2. 页面方法
      1. 开启浏览器缓存
         HTTP1.1提供的缓存方法主要有2中 
         1. Expires 和 Cache-control：max-age，设置资源的有效期，在资源的有效期内直接从本地缓存中拿取
         3. Last-Modified和ETag.：Last-Modified标记文件最后一次修改的时间，浏览器请求是在头部加入上次请求缓存下来的Last-Modified时间，若两次请求期间服务器的内容没有修改，服务器返回304 Not Modified，则不下载资源，浏览器直接使用本地缓存;否则，服务器会返回200以及更新后的版本。ETag是服务器对于文件生成的Hash散列，其生成算法与最后一次修改的时间相关。浏览器第二次请求发送上次的ETag信息，服务器通过简单的比对就知道是否应该返回304还是200。PageSpeed建议，要为资源指定Last-Modified或ETag标头，以便启动缓存验证。
      2. 页面内容
         1. 设置HTML字符集编码，让浏览器可以立即执行脚本
         2. 内嵌样式和元素从body移动到head
         3. 小型样式表或者脚本内嵌到html，减少请求
         4. 压缩HTML
         5. 为图片指定大小，减少重排
         6. 减少HTML嵌套深度，嵌套越深，重排重绘的代价越高，滚动流畅度都会降低
         7. 使用HTML新标签，语义化，速度快，浏览器识别能力强
         8. 不适用import标签
         9. 避免使用滤镜
         10. 合并压缩CSS
         11. 减少渐变阴影的使用
         12. 模块化精简CSS，重复使用
         13. 合理使用CSS3动画，使用translate3d开启硬件加速
         14. 使用雪碧图
         15. 脚本模块化，压缩，按需加载，采用事件委托，避免反复操作DOM
         16. 延缓JS解析
         17. 压缩图片，根据图片使用的地方设置图片的大小



# 排队问题
    在http1.0/1.1中，chrome最多允许对同一host有6个连接，如果同时加载资源过多将导致加载排队，解决这种问题
        1. CSS sprite
        2. js/css 压缩
        3. 采用缓存
        4. 按需加载
        5. 将资源存放在不同的子域名下，将图片以及静态资源分开可以大大加速网页加载时间（http2.0不适用）

# 等待时间过长(TFFB)
    一般低于200ms，如果时间过长，会导致加载缓慢，可能存在的问题
        1. 网络状况较差（可以做本地测试排除或者优化）
        2. 服务器响应较慢（优化数据库，资源缓存，修改web配置，迁移服务器）

# 下载时间过长
    下载时间过长，可以尝试提高网络带宽，压缩资源