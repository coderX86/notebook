# 柯里化

不论是 JavaScript 的基础教程还是函数式编程领域，都会经常提到一个词叫做 `柯里化`，柯里化的概念非常简单：`只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数`，一般的博客或者教程里面都会用下面这一段代码来说明 `柯里化` 怎么用

```js
function curry(a) {
  return function (b) {
    return function (c) {
      return a + b + c;
    };
  };
}

curry(1)(2)(3); // 6
```

这里定义了一个累加的柯里化函数，每次调用函数之后都会返回以个新的函数，第三次调用之后返回累加结果。如果只是用来理解柯里化的概念，那么到这里似乎也就结束了，但是柯里化的概念很简单，却可以用得非常灵活

## 无限制累加

上面这个案例，我们可以稍微改造一下，让它可以调用任意次数，并且能拿到计算结果，比如： `curry(1)`、`curry(1)(2)`、`curry(1)(2)(3)`

```js
function Curry(x) {
  let res = x;
  const add = y => {
    res += y;
    return add;
  };
  return add;
}
```

为了实现任意次数的链式调用，那我们肯定不能像上面一样返回多次嵌套函数。想要任意次数的调用，有一个很好的办法就是使用递归，即：函数返回调用自身的结果。上面的案例中，用到了另外一个概念 `闭包`，用来缓存每次调用计算的结果，为了能够链式调用，我们返回了一个函数，之后每次调用这个返回的函数时再次返回这个函数本身，这样我们就能实现任意次数的调用了。

但是这样也存在一个问题，我们虽然实现了任意次的链式调用，但是我们并不能拿到结算的结果，因为返回的结果是一个`Function`。得益于 JavaScript 中一切皆对象的设计思想，函数本身也是一个对象，我们可以在它上面添加属性，结合 JavaScript 的隐式类型转化，我们就可以拿到计算结果。JavaScript 隐式类型转化的原理是：JavaScript 中的对象，在期望得到一个数值的地方，会调用对象的`valueOf`方法，将对象转为数值，这个方法在 Object 类上面有默认实现，也可以自己实现这个方法，正好 `Function` 类型也是一个对象，我们可以在函数上添加这些方法或者属性。

下面这是一个简单的 demo，可以说明 `valueOf` 的作用

```js
console.log(+{}); // NaN
// 我们自定义一下valueOf方法，固定返回100
Object.prototype.valueOf = () => 100;
console.log(+{}); // 100
```

知道了对象怎么转数值了，那么拿到计算的结果就很简单了，下面就是任意次连续调用的柯里化函数的实现方式，原理也很简单，需要一丢丢 JavaScript 的基础知识

```js
function Curry(x) {
  let res = x;
  const add = y => {
    res += y;
    return add;
  };
  add.valueOf = () => res;
  add.toString = () => `${res}`;
  return add;
}
```
