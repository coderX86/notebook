# javascript面试题

> 本文档收藏Javascript当中一些奇奇怪怪的问题并且附上自己的见解

```javascript
    [1,2,3].map(parseInt)    // [1, NaN, NaN]
```

解答：本题的关键在于`map`函数的回调函数的参数，[value,index,arr],这里`parseInt`函数被作为回调函数使用
但是parseInt只接收2个参数也就是前两个，map的每一次回调parseInt的参数如下：

- 第一次：1,0
- 第二次：2,1
- 第三次：3,2

首先，parseInt可以接收的第一个参数为待转换的字符串，不是字符串则自动转换为字符串，
第二个参数为2-36之间的整数，默认为10，如果指定为0等同与10，如果指定为负数则返回NaN，如果第二个参数小于第一个参数也会返回NaN

```javascript
    arr = [1,2,3,4]
    arr.forEach((value,index,arr)=>{
        console.log(value,index,arr)
        if(value == 2){
        arr.shift()
        }
    })
    // 1 0 (4) [1, 2, 3, 4]
    // 2 1 (4) [1, 2, 3, 4]
    // 4 2 (3) [2, 3, 4]
    // 可以很直接的看出forEach是根据索引遍历的，当索引修改的时候会影响遍历次数
```

```javascript
    var name = 'World!';
    (function () {
        if (typeof name === 'undefined') {
            var name = 'Jack';
            console.log('Goodbye ' + name);
        } else {
            console.log('Hello ' + name);
        }
    })();      // Goodbye Jack
```

解答：因为var会存在变量提升，即变量的声明在预编译的时候,提升到函数的最开始，但是赋值语句依然会指定到这里的时候才会执行，
所以这里实际上在闭包里面创造了一个`暂时性死区`，声明了一个局部变量name没有赋值，所以为`undefined`，如果使用`let`、`const`定义则不会出现这种问题

```javascript
    []===[]         // false  
    !![]===true    // true
```

解答：`[]===[]`是因为使用`[]`直接创建了一个空数组，第一行语句就相当于创建了两个数组，但是`typeof []==="object"`，即数组也是一个对象，属于引用类型，
引用类型比较的时候是比较两个变量的内存地址，所以不相等  
第二行是因为 `!` 是一个右操作符，且优先级高于`===`，所以先算 `[]`，再计算`![]`，`!`是一个类型转换符号，将后面的表达式转变为布尔值，
`[]`属于对象转换为`true`,`!!`取反再取反等于原来本身，也就是`true`，然后`true===true`

```javascript
    1 + - + + + - + 1
```

解析：以上表达式中的`+`、`-`除了加减作用之外，还有求反，以及转为数字类型的作用，这些作用都是`右操作`符，所以从右边往左读，解析下来就是：

- `1 + - + + + - 1`
- `1 + - + + - 1`
- `1 + - + - 1`
- `1 + - - 1`
- `1 + + 1`
- `1 + 1`
