ECMAscript  
	0.14*100   不精确
	0.1+0.2!=0.3	

预编译
	函数申明整体提前

	变量申明提前,赋值语句位置不变	函数体内部的变量只会在执行前一刻申明

	局部变量可以在局部变量作用于里面覆盖全局变量

	不用var申明的变量默认为全局变量

    let:        

作用域
	function.[[scope]]	函数的作用域
	函数的执行器上下文
		每个函数在创建的时候会创建一个执行期上下文  多次调用多次创建 每次运行完后删除
		执行期上下文会保存函数内部申明的变量、函数及其值
		在申明函数的时候  函数的执行器上下文只有GO(Global Object) 包含 this window document以及其他申明过的全局变量
		在函数预编译时期（函数执行前一刻），函数的执行器上下文的第一位保存为AO（局部变量信息）第二位放GO
		在函数内部访问变量的时候会首先从执行器上下文的第0位开始查找变量

	嵌套函数（闭包）
		内部的函数会创建一个自己的作用域链，同时会将外部函数的作用域保存在自己的执行器上下文的第二位，同时将GO放在最后一位
		内部函数访问变量的时候最先查看自己的执行器上下文，再查看外部函数的执行器上下文，最后查看全局变量
		内部函数执行完之后会删除自己的执行器上下文，但是第二位的不会被删除
		将内部函数保存在外部函数外面会生成闭包，会使内部函数的作用域链延长（第二位是相邻的外部函数的作用域）
	闭包的作用
		累加器
		可以做缓存（存储结构）
		实现封装，属性私有化
			
立即执行函数-------适合做初始化工作

	形式一：(function(){}())	//w3c建议使用第一种
	形式二: (function(){})()

	只有表达式才能被执行符号执行	()  +  -  ++  --  都可以执行

	function(){}()			//编译报错
	(function(){})()		//可以编译执行		只会执行一次
	var fn=function(){}();		//可以被执行		只会执行一次
	var fn=function(){};		//赋值运算将函数表达式赋值到变量，可以多次执行
	
对象
	对象属性可以 ：增、删、改、查   删除使用delete obj.proterty
	
	对象的创建方法：
	    1.对象字面量    （JSON）
	    2.构造函数	
                a).系统自带的自带函数 
                b).自定义构造函数	大驼峰命名法    ---普通函数 小驼峰命名法
            
                JSON和javascript对象的差别
                JSON------>对象的属性用双引号括起来
                javascript对象-------->对象的属性不用括起来
		JSON:
			var JSON={
				"name":"name",
				"age":"age",
			}
		javascript对象:
			var Obj={
				name:"name",
				age:age,
			}

	引用类型-------->变量名（引用地址）存放在栈，具体的值存放在堆
	值类型------->存放在栈内

包装类
	在原始值设置属性值的时候会调用包装类创建一个新的临时对象，将属性交给临时变量，然后删除该对象，原始对象不能拥有属性、方法

charCodeAt()
	返回Unicode编码，当返回值小于255时为英文，当返回值大于255的时候为中文，中文占两个字节，英文占一个字符

原型
    #####################################################################################
    理解：原型是给构造函数添加的属性，这些属性在该构造函数创建对象的时候会直接赋给创建的对象
    #####################################################################################
	
	1.原型
        是function对象的一个属性，它定义了构造函数的生产对象的公共祖先，
        通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是对象
	2.特点
        利用原型的特点可以提取共有属性的，如果自己没有该属性则查看父级属性
	3.查看原型
        obj._proto_			    //对象的原型
        obj.constructor     	//对象的构造器	---->  指向对象的构造函数   可以手动更改 为其它构造函数
	4.原型链
        原型是一个对象，可以手动指向对象，借此实现原型链
		当查看对象的属性的时候会首先查看自己的属性中有没有，没有就查看父级的属性，如果没有则继续向上级查看
		指定原型：
            obj1.__proto__ = obj2.prototype         //前后有两个下划线
        原型链终端：
            # Object 的原型是所有原型的终端
            Object.prototype
		
    5.原型链上的增、删、改、查
        删除：
            原型链上属性只能由自己删除，子级不能删除父级的属性
        修改：
            当父级原型包含应用值的属性时，子级可以增加其引用的值
            FunctionA.prototype = Obj
	6.创建没有原型的对象
            var obj = Object.creat(proto)     
            proto可以是null或者Object
            当为null的时候创建的对象原型终端为null而不是Object.proterty
		


构造函数构造对象流程
	定义一个对象this
    给this对象的 第一个属性 为__proto__:Obj.prototype
    将构造函数中的其他参数添加到对象
	添加完所有属性后  返回一个对象（即便显示表示返回非对象，也会返回一个对象）
    构造函数构建对象的时候需要使用 New关键字

Call/apply
	1.作用	改变this指向
	2.区别  传参列表不同
	使用：
        fn();
        fn.call()

	改变this指向案例：
		var person=New Person();
		var obj={}
		function Person(name){
			this.name=name;
		}
		Person.call(obj,arg1,arg2...);	 
        // call的第一个参数会改变this的指向，后面的参数对应形参列表 
    Call/Apply区别：
	    call需要传递实参列表，apply只能传递一个数组，所有的参数都放在数组里面传递
 
事件冒泡
	子级的事件会通过冒泡，向上传递到上级，可以用通过
	event.cancelBubble = true;
	event.stopPropagation();
	//  event  是函数/方法中的形参


继承模式
	原型链 -----> call/apply -----> 公有原型
	
	共有原型
		function Father(){}
		function Son(){}
		Son.prototype=Father.prototype;
		//因为Father的原型是一个对象（引用值）所以将Son 的原型指向Father的原型，他们将指向他同一个对象
		//缺点：son修改原型的时候Father的原型也会受到影响

		----升级----（圣杯模式）
		function F(){}
		F.prototype=Father.prototype;
		Son.prototype=new F();
		//修改过后 Son 的原型来自于新构建的一个对象，和father没有直接影响，但是依然继承自father

名称空间（对象）
	webpack------名称空间管理工具
	方案1：
		采用对象，将自己的变量存放在对象下面
	方案2：
		采用立即执行函数+闭包，将自己的变量函数返回到一个变量等待调用
	
利用闭包实现是优私有化变量
	function Fn1(){
		var name="xiaoming";
		function showName(){
			console.log(name);
		}
        function changeName(name){
            name=name
        }
        return {
            showName,
            changeName,
        }
	}
	var fn1=new Fn1();
	//当使用该函数创建对象的时候，会创建一个只有showName方法的一个对象
    //内部的name不是属性,不会返回给新对象，但是因为闭包的原因，内部的showName可以访问
	
模拟Jquery的链式语法：
    function People(){
        this.smoke=function(){
            console.log("抽烟")
            return this
        }
        this.drink=function(){
            console.log("喝酒")
            return this
        }
        this.run=function(){
            console.log("跑")
            return this
        }
    }
    f=new People()
    f.drink().run().smoke().drink().run().smoke().drink().run().smoke()

对象的枚举:
    采用for in 循环
    专门用来遍历对象,也可以用来遍历数组
    在枚举中访问对象的属性值不能使用obj.pro的方式
    只能使用obj[pro]的方式访问
    遍历的时候默认会访问到原型中规定的属性
    hasOwdProperty(pro):
        用于检测对象的某一个属性是不是属于自己的属性，如果来自于原型则返回False
    pro in obj :
        判断对象有没有这个属性
    obj instanceof() Constructor:
        官方：用于判断obj是否是 Constructor构造出来的
        总结：A对象的原型链上有没有B的原型


克隆
    对象属于引用类型，当给一个变量赋值的时候，实际上是给他起了别名，两个变量都指向同一个地址，即同一个对象
    // 深层克隆
        1.判断是不是原始值
        2.判断是数组还是对象
        3.建立行的数组和对象


类数组
    类数组为一个对象
    必须包含length属性
    属性为数字
    最有有数组的push()方法  
    可以像数组也能像对象一样访问对象
        // DOM 中的很多属性都属类数组


数组去重
    // 采用对象的hashcode

    Array.prototype.unique = function () {
        var obj = {},
            arr=[]
            len=this.length;
        for (var i=0;i<len;i++) {
            if (!obj[this[i]]) {
                obj[this[i]] = '0';
                arr.push(this[i])
            }
        }
        return arr
    }    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    















































鼠标定位
		属性		说明											兼容性
	---------------------------------------------------------------------------------------------------------------------
	clientX		    以浏览器左窗口左上角为原点，定位x轴坐标				所有浏览器不兼容  safari
	clientX		    以浏览器左窗口左上角为原点，定位y轴坐标				所有浏览器不兼容  safari
	offsetX			以当前事件对象的左上定点为原点，定位x轴左边			所有浏览器不兼容  Mozila
	offsetY			以当前事件对象的左上定点为原点，定位y轴左边			所有浏览器不兼容  Mozila
	pageX			以document对象左上角为原点，定位x轴				  所有浏览器不兼容	IE	
	pageY			以document对象左上角为原点，定位y轴				  所有浏览器不兼容	IE	
	screenX			以计算机屏幕左上角为原点，定位x轴				   所有浏览器	
	screenY 		以计算机屏幕左上角为原点，定位y轴				   所有浏览器	
	layerX		 	以最近的绝对定位的父元素（如果没有则为document对象） Mozila 和 safari
					左上角为原点，定位x轴
	layerY		 	以最近的绝对定位的父元素（如果没有则为document对象） Mozila 和 safari
					左上角为原点，定位y轴
