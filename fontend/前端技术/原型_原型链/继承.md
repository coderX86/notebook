# 继承方式

- **原型继承**

  ECMA-262 默认使用原型继承

  - 优点
    - 复用父类属性、方法
  - 缺点
    - 子类实例共享父类构造函数中的引用属性
    - 不能向父类实例传参

- **盗用构造函数**

  在子类中使用 foo.call() 调用父类实例化自身

  - 优点
    - 子类实例不共享父类构造函数中的引用属性
    - 可以向父类传参
  - 缺点
    - 子类不能继承父类原型上的属性
    - 子类不是父类的实例 `instanceof` 无法检测

- **组合继承**(原型继承+构造函数)

  子类使用 `foo.call()` 调用父类实例化自身，指定子类的原型 `Child.prototype = new Father()`。 `记得修复 Child.prototype.constructor = Child, 否则实例化的对象为Father类型`

  - 优点
    - 保留构造函数： 可以向父类传参
    - 保留原型链：父类实例原型上的方法公用
    - 父类构造函数中的引用类型不共享
  - 缺点
    - 父类构造函数中的属性存在实例以及原型上

- **组合优化**(原型继承+构造函数) 子类指向父类的原型，修改子类的

  相对于 `组合继承`, 子类的原型指向父类的原型，而不是父类的实例 `Child.prototype = Father.prototype`。 `记得修复 Child.prototype.constructor = Child, 否则实例化的对象为Father类型`

  - 优点
    - 保留构造函数：可以向服了传参
    - 保留原型： 父类实例原型上的方法公用
    - 父类构造函数中的引用类型不共享
  - 缺点
    - 在子类原型上添加属性，同时在父类型上添加。不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数

- **组合寄生** （完美继承 / 圣杯模式）
